# CSCI 12033: Computer Architecture and Design - Lecture 01

## Course Information

*   **Number of Credits:** 3
*   **Course Delivery:** Lectures, Tutorials, In-class activities

## Learning Outcomes of the Module

Upon successful completion of this course, a student will be able to:

1.  Understand the basic architecture of a computer.
2.  Describe how a computer executes instructions.
3.  Implement simple assembly programs.

## Assessment Strategy

**Continuous Assessments:**

*   Group Assignment and Presentation - 10%
*   Mid Exam (7th Week) - 20%
*   In-Class Quiz (Open book) - 10%

**Final Evaluation:**

*   Theory Examination - 60%

## Contents

1.  Introduction
2.  Components of the Little Man Computer
3.  Registers
4.  Instruction Set
5.  Execution Cycle
6.  Memory
7.  Limitations
8.  Sample Programs

## 1. Introduction

The Little Man Computer (LMC) is a simplified computer model designed to teach the basics of computer architecture and programming. It serves as an excellent tool for beginners to learn how computers function and how to write simple programs.

*   **Simplified Computer Model:** Designed specifically for teaching computer architecture and programming basics.
*   **Beginner-Friendly:** Ideal for understanding how computers work and writing simple programs.
*   **Minimalist Design:** Utilizes a small number of registers, limited memory, and a restricted instruction set for ease of understanding.
*   **Von Neumann Architecture:** Simulates the principles of modern computer architecture, where data and instructions share the same memory space.
*   **Invented in 1965:** Created by Dr. Stuart Madnick and remains a widely used teaching tool.
*   **Little Man Concept:** Represents the control unit (CPU), responsible for handling the fetching, decoding, execution, and I/O management of instructions.
*   **Programming Options:** Can be programmed using either Machine Code or Assembly Language.

## Instruction Cycle (Fetch-Decode-Execute)

The fundamental process by which a CPU executes instructions.

*   **Fetch:** The CPU retrieves the instruction from memory at the address indicated by the Program Counter and loads it into the instruction register.
*   **Decode:** The CPU interprets the fetched instruction to determine the operation to be performed and identify the operands (data or memory addresses) involved.
*   **Execute:** The CPU performs the specified operation using the Arithmetic Logic Unit (ALU) and other components to process data, store results, or change the program flow.

This cycle, which is similar for most instructions, can be broken into two main parts:

1.  **The Fetch Portion:** The "Little Man" (representing the CPU's control unit) finds out what instruction needs to be executed by fetching it from memory. This must happen first; until the fetch is complete, the CPU doesn't know the next instruction.
2.  **The Execute Portion:** The "Little Man" actually performs the task specified by the instruction. The actions performed during the execute portion vary depending on the specific instruction.

## 2. Components of the Little Man Computer

The Little Man Computer consists of the following main components:

1.  **Accumulator:**
    *   A register used to temporarily hold data being processed.
    *   Can store positive or negative values.
    *   Used for arithmetic operations like ADD and SUB.
    *   Stores the intermediate and final results of operations.
2.  **Program Counter (PC):**
    *   A register that keeps track of the memory address of the next instruction to be fetched.
    *   Used to fetch instructions sequentially from memory.
    *   Increments to point to the next instruction after each instruction is fetched (unless a branch/jump instruction occurs).
3.  **Memory:**
    *   Stores both program instructions and data.
    *   Limited capacity, typically 100 memory locations (mailboxes in the LMC analogy), addressed from 00 to 99.
    *   Each location holds either an instruction or a single data value.

*(An image representing the LMC setup with mailboxes, calculator, input/output baskets, a little man, and instruction location counter is typically used to illustrate these components).*

## 3. Registers

Registers are small, high-speed storage locations within the CPU used to temporarily hold data and control information during processing. The two main registers in the LMC are the Accumulator and the Program Counter.

*   **Accumulator (ACC):**
    *   Holds the data currently being manipulated or processed by the CPU.
    *   Stores positive or negative numerical values.
    *   Its value is modified by arithmetic operations (ADD, SUB) and data movement operations (LDA, STA, INP, OUT).
    *   Stores the results of operations before they are potentially written back to memory or output.
*   **Program Counter (PC):**
    *   Holds the memory address of the instruction that is about to be fetched and executed.
    *   It is automatically incremented after fetching an instruction to point to the next instruction in sequence.
    *   Its value can be modified by branch/jump instructions (BRA, BRZ, BRP).

## ACTIVITY

Answer the following questions. You may discuss with classmates and use any online references.

1.  Why is the instruction cycle called a cycle?
2.  Even if he runs out of instructions to execute, the Little Man only stops trying to execute instructions under one condition. What is that condition? What happens if the Little Man runs out of instructions and that condition is not met?
3.  Is assembly language easier or more difficult to translate than high-level languages? Justify your answer.
4.  Are there any languages that are at a lower level than assembly?

## 4. LMC Instruction Set

The instruction set is the set of commands that the Little Man Computer understands and can execute. Each instruction tells the computer to perform a specific task.

Instructions in LMC consist of an **Opcode** (Operation Code) specifying the task and, for most instructions, an **Operand/Parameter** providing additional information like a memory address.

*   **Machine Code:** The numerical code understood and executed by the computer. In LMC, each instruction corresponds to a specific 3-digit machine code. The first digit is the opcode, and the last two digits often represent a memory address.
    *   Example: `LDA (Load)` -> Opcode 5
    *   Example: `ADD (Addition)` -> Opcode 1
    *   Machine code directly controls the CPU's operations.

*   **Mnemonic Code:** Human-readable abbreviations that represent the machine code instructions. They simplify programming compared to using raw numerical machine code.
    *   Example: `ADD` represents the addition operation.
    *   Example: `LDA` represents the load operation.

Here is a table of the LMC Instruction Set:

| Instruction          | Mnemonic | Machine Code | Further Information                                                                                                                                 |
| :------------------- | :------- | :----------- | :-------------------------------------------------------------------------------------------------------------------------------------------------- |
| Load                 | LDA      | 5xx          | Load the contents of address `xx` onto the accumulator. *Note: the contents of the address are not changed.*                                            |
| Store                | STA      | 3xx          | Store the contents of the accumulator to address `xx`. *Note: the contents of the accumulator are not changed.*                                         |
| Add                  | ADD      | 1xx          | Add the contents of address `xx` to the accumulator. *Note: the contents of the address are not changed and the total cannot exceed 999.*               |
| Subtract             | SUB      | 2xx          | Subtract the contents of address `xx` from the accumulator. *Note: the contents of the address are not changed.* *Note: If a subtract instruction causes negative results then a negative flag will be set so that BRP can be used properly.* |
| Input                | INP      | 901          | Copy a value from the "in box" (input device) onto the accumulator.                                                                                   |
| Output               | OUT      | 902          | Copy the value from the accumulator to the "out box" (output device). *Note: the contents of the accumulator are not changed.*                         |
| End                  | HLT      | 000          | Stop the LMC simulator, halting the execution of the program.                                                                                       |
| Branch always        | BRA      | 6xx          | Unconditionally set the program counter to address `xx`, causing execution to jump to that location.                                                  |
| Branch if zero       | BRZ      | 7xx          | If the contents of the accumulator are ZERO, set the program counter to address `xx`. Otherwise, proceed to the next instruction.                     |
| Branch if zero or positive | BRP      | 8xx          | If the contents of the accumulator are ZERO or positive (i.e., the negative flag is not set), set the program counter to address `xx`. Otherwise, proceed to the next instruction. |
| Data storage         | DAT      | N / varies   | Reserve the memory address reached when this instruction is compiled as data. A value `N` can be optionally stored at the memory address using `DAT N`. |

These instructions can be combined to create programs. Understanding each instruction is fundamental to LMC programming.

### Instruction Set Categories:

*   **Arithmetic & Memory Operations:**
    *   `ADD xx`: Adds the value from memory location `xx` to the Accumulator.
        *   Example: `ADD 10` -> Adds value at memory location 10 to Accumulator.
    *   `SUB xx`: Subtracts the value from memory location `xx` from the Accumulator.
        *   Example: `SUB 20` -> Subtracts value at memory location 20 from Accumulator.
    *   `STA xx`: Stores the current value of the Accumulator into memory location `xx`.
        *   Example: `STA 30` -> Stores Accumulator value at memory location 30.
    *   `LDA xx`: Loads the value from memory location `xx` into the Accumulator.
        *   Example: `LDA 40` -> Loads value from memory location 40 into Accumulator.

*   **Branching & Control:**
    *   `BRA xx`: Unconditional jump (branch always) to memory location `xx`.
        *   Example: `BRA 50` -> Jumps to memory location 50.
    *   `BRZ xx`: Jumps to memory location `xx` *if* the Accumulator value is zero.
        *   Example: `BRZ 60` -> Jumps to memory location 60 if Accumulator = 0.
    *   `BRP xx`: Jumps to memory location `xx` *if* the Accumulator value is positive (greater than or equal to zero).
        *   Example: `BRP 70` -> Jumps to memory location 70 if Accumulator >= 0.
    *   `HLT`: Halts program execution.
        *   Example: `HLT` -> Stops the program.

*   **Input/Output Operations:**
    *   `INP`: Reads an input value from the input device and stores it in the Accumulator.
        *   Example: `INP` -> Reads input value into Accumulator.
    *   `OUT`: Outputs the current value from the Accumulator to the output device.
        *   Example: `OUT` -> Outputs Accumulator value.

*   **Data Definition:**
    *   `DAT [N]`: Declares a memory location to be used for storing data. Optionally, a value `N` can be initially stored in that location. This is not an executable instruction but a directive for the assembler/simulator.
        *   Example: `DAT 80` -> Reserves a memory location (at the point it is assembled) and initializes it with the value 80.

## 5. Execution Cycle

The LMC Execution Cycle repeats for each instruction in the program, following the Fetch-Decode-Execute pattern.

**Steps of the Execution Cycle:**

1.  **Fetch:** The CPU (Little Man) retrieves the instruction from the memory location pointed to by the Program Counter.
2.  **Decode:** The CPU interprets the fetched instruction to understand what operation is required and which memory location (operand) is involved (if any).
3.  **Execute:** The CPU performs the operation specified by the instruction. This might involve using the Accumulator, interacting with memory, or performing I/O.
4.  **Update PC:** The Program Counter is incremented to point to the next instruction in the program sequence. If the executed instruction was a branch/jump, the PC is updated with the target address instead of simply incrementing.

**Sequential Execution:** Instructions are typically executed one after another, in the order they appear in memory, starting from the address specified initially.

**Branching & Jumping:** Instructions like `BRZ`, `BRP`, and `BRA` allow the program counter to be changed non-sequentially, enabling control flow structures like loops and conditionals. Jumps occur to a specified memory location based on conditions (Accumulator is 0, positive, or always).

*(An image illustrating the LMC execution cycle is typically shown, depicting steps like reading address from PC, going to mailbox, reading instruction, performing operation (e.g., in calculator), and updating PC).*

## 6. Memory

Memory in the LMC is where both program instructions and data are stored for program execution. It has a limited capacity.

*   **Capacity:** Typically 100 memory locations, often referred to as "mailboxes," addressed from 00 to 99.
*   **Storage Type:**
    *   **Instructions:** Stored as numerical machine codes (binary representation is implied, but they are often viewed as decimal numbers 000-999).
    *   **Data values:** Stored as decimal numbers.
*   **Memory Address:** Each memory location has a unique numerical address (a number representing its position). These addresses are used by instructions as operands to access the stored instructions or data during execution.
*   **Memory Function:**
    *   Stores the entire program (instructions and data).
    *   Instructions access data stored in memory locations using their addresses as operands.
    *   The Accumulator and Program Counter are also conceptually linked to memory interaction (fetching from memory, storing results back to memory).

## KNOWLEDGE CHECK

In the Little Man Computer (LMC), which of the following statements is TRUE?

A) The Accumulator is used to store program instructions.
B) The Program Counter holds the result of arithmetic operations.
C) Instructions in LMC are stored in memory as binary codes.
D) The LMC can execute multiple instructions at the same time.

**Knowledge Check Explained:**

A) **False.** The Accumulator stores data being processed and results, not program instructions. Instructions are stored in memory.
B) **False.** The Program Counter keeps track of the address of the *next* instruction. The Accumulator stores the result of arithmetic operations.
C) **True.** Instructions in LMC are represented as numerical machine codes, which are the binary representation understood by the computer, stored in memory.
D) **False.** The LMC is a simple sequential processor; it executes one instruction at a time, not multiple simultaneously.

## 7. Limitations

The LMC, being a simplified model, has several limitations:

1.  **Limited Instruction Set:**
    *   Only includes basic arithmetic (ADD, SUB), memory operations (LDA, STA), input/output (INP, OUT), and simple control transfer (BRA, BRZ, BRP, HLT).
    *   It is difficult or impossible to write complex programs requiring advanced operations, complex data types, or sophisticated control structures directly.

2.  **Small Memory Size:**
    *   Typically limited to around 100 memory locations (addresses 00-99).
    *   This severely limits the storage capacity for large data sets and complex programs.

## Overcoming the Limitations of the Little Man Computer (LMC)

While inherently limited, some basic programming techniques can help manage complexity within the LMC framework:

*   **Using Subroutines:** Breaking large programs into smaller, more manageable, and potentially reusable parts. This helps manage complexity despite the limited instruction set and memory.
*   **Using Labels & Branching:** Labels are symbolic names for memory locations. Branching instructions (BRZ, BRP, BRA) allow jumping to these labeled locations based on conditions or unconditionally, enabling basic program control flow.
*   **Using Assembly Language:** Programming in LMC Assembly Language (using mnemonics like LDA, ADD) is a low-level language closer to machine code but significantly easier for humans to write and read than raw numerical machine code. This helps write programs more efficiently within LMC's constraints.

## 8. Sample Programs

### Sample Program 1: Add Two Stored Values

This program adds the values 5 and 10 together and then outputs the result.

```assembly
START   LDA FIVE    # Load the value at memory location FIVE into the Accumulator (ACC = 5)
        ADD TEN     # Add the value at memory location TEN to the Accumulator (ACC = 5 + 10 = 15)
        OUT         # Output the value in the Accumulator (15)
        HLT         # Halt the program

FIVE    DAT 5       # Declare a memory location labeled FIVE and store the data value 5 in it
TEN     DAT 10      # Declare a memory location labeled TEN and store the data value 10 in it
```

**Explanation of Execution:**

1.  **`START`**: This is a label indicating the start of the program. The Program Counter is initialized to the memory address where this instruction is loaded.
2.  **`LDA FIVE`**:
    *   **Fetch:** Instruction at `START` address is fetched.
    *   **Decode:** Recognize `LDA` (Load) instruction, operand `FIVE` (which corresponds to a memory address).
    *   **Execute:** Go to the memory address labeled `FIVE`, read its content (which is 5), and load it into the Accumulator. ACC = 5.
    *   **Update PC:** Increment PC to the next instruction's address.
3.  **`ADD TEN`**:
    *   **Fetch:** Instruction at the new PC address is fetched.
    *   **Decode:** Recognize `ADD` instruction, operand `TEN` (which corresponds to a memory address).
    *   **Execute:** Go to the memory address labeled `TEN`, read its content (which is 10), and add it to the current value in the Accumulator. ACC = 5 + 10 = 15.
    *   **Update PC:** Increment PC.
4.  **`OUT`**:
    *   **Fetch:** Instruction is fetched.
    *   **Decode:** Recognize `OUT` (Output) instruction.
    *   **Execute:** Take the value from the Accumulator (15) and send it to the output device.
    *   **Update PC:** Increment PC.
5.  **`HLT`**:
    *   **Fetch:** Instruction is fetched.
    *   **Decode:** Recognize `HLT` (Halt) instruction.
    *   **Execute:** Stop the program execution.
    *   **Update PC:** N/A (program halted).
6.  **`FIVE DAT 5`**: This line uses the `DAT` directive. It tells the assembler/simulator to reserve a memory location, associate the label `FIVE` with its address, and store the initial value 5 in it. This location is treated as data, not an instruction, during execution unless explicitly jumped to.
7.  **`TEN DAT 10`**: Similar to the previous line, reserves a location, labels it `TEN`, and stores 10 as data.

The execution cycle repeats for each instruction in the program, starting with the first instruction (`LDA FIVE` in this case, as `START` is a label) and ending with `HLT`. The Program Counter is updated after each instruction's execution to determine the next instruction to fetch.

### Sample Program 2: Input a Number, Add 5, Output Result

This program prompts the user for a number, adds the value 5 to it, and outputs the result.

```assembly
        INP     # Read number from input device and store in Accumulator
        STA NUM # Store the number from the Accumulator into memory location labeled NUM
        LDA NUM # Load the number back from memory location NUM into the Accumulator
        ADD FIVE # Add the value from memory location FIVE to the number in the Accumulator
        OUT     # Output the result (Accumulator value) to the output device
        HLT     # Halt the program

NUM     DAT     # Declare a memory location labeled NUM for data storage (initial value is 0 or undefined by default)
FIVE    DAT 5   # Declare a memory location labeled FIVE and store the data value 5 in it
                # (LMC uses only direct addressing mode, so DAT values are accessed by label/address)
```

## WHAT DID WE TALK ABOUT?

The purpose of the Little Man Computer (LMC) is to provide a simple, understandable model for learning computer basics and programming. It is based on the **Von Neumann architecture**, where data and instructions reside together in the same memory space.

Key Parts of the LMC are:

*   **Accumulator:** Holds data being processed.
*   **Program Counter (PC):** Tracks the address of the next instruction to be executed.
*   **Memory:** Stores instructions (represented as binary/machine code) and data (decimal values), limited to 100 locations.

This lesson discussed the Little Man Computer architecture, its components (Accumulator, PC, Memory), instruction set, execution cycle (Fetch-Decode-Execute), memory organization, and its inherent limitations. We walked through sample programs to demonstrate how the Little Man Computer works and briefly touched upon strategies to overcome its limitations within its framework.

## 2 - MINUTE PAPER

Describe the key takeaway from today's lesson in your own words.

*(An image of a person scratching their head, looking puzzled, is typically shown here)*.